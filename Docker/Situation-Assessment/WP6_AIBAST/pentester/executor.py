import json
import subprocess
import os
import re
from typing import Dict, List, Optional, Tuple
from collections.abc import Callable
from .utils import LLMtoCommand, Task
from dotenv import load_dotenv
from langchain.prompts import PromptTemplate
from .prompt_templates import (
    nmap_executer_template,
    metasploit_executer_template,
)
from .logging_setup import get_logger

logger = get_logger(__name__)
# Load environment variables from .env file
load_dotenv()



input_file = r"./pentester/planner_tasks.json" #there we could add a central path


# def parse_task(data: dict) -> Task:
#     try:
#         task_type = TaskType(data["task_type"])
#     except ValueError:
#         raise ValueError(f"Unsupported task type: {data['task_type']}")

#     return Task(
#         task_id=data["task_id"],
#         description=data["description"],
#         target=data["target"],
#         task_type=task_type,
#         dependencies=data.get("dependencies", []),
#     )


def check_metasploit_success(
    metasploit_output: str,
) -> bool:
    failure_patterns = [
        # The most common "soft" failure
        re.compile(
            r"\[\*\]\s+exploit completed, but no session was created",
            re.IGNORECASE,
        ),
        # Generic exploit failures
        re.compile(r"\[-\]\s+exploit failed", re.IGNORECASE),
        # Failure due to bad options or other module errors
        re.compile(r"\[-\]\s+module run failed", re.IGNORECASE),
        # Connection errors
        re.compile(r"\[-\]\s+connection refused", re.IGNORECASE),
        re.compile(r"\[-\]\s+unreachable", re.IGNORECASE),
        re.compile(r"\[-\]\s+Unknown command:", re.IGNORECASE),
    ]

    lines = metasploit_output.splitlines()

    # --- Second Pass: If no success, scan for known failure messages ---
    # We return on the first failure pattern we find.
    for line in lines:
        for pattern in failure_patterns:
            if pattern.search(line):
                return False

    return True


class Executor:
    """
    Automated Cybersecurity Task Execution with LLM & Metasploit/Nmap

    **Workflow Steps:**
    1 **Receive Task** → Accepts a task with a description and target.
    2 **Generate Command** → Uses an LLM to create an optimized command.
    3 **Validate & Parse** → Ensures the command is correctly formatted.
    4 **Execute** → Runs the validated command and captures output.

    **Main Methods:**
    - `execute_command(task)` → Orchestrates the full workflow.
    - `create_nmap_task(description, target)` → Generates Nmap command.
    - `create_msf_task(description, target)` → Generates Metasploit command.
    - `parse_nmap(command)` → Validates and extracts Nmap command.
    - `parse_msf(command)` → Validates and extracts Metasploit command.
    - `execute_nmap(command)` → Runs Nmap command.
    - `execute_msf(command)` → Runs Metasploit command.
    """

    def __init__(
        self,
        exec_llm,
        container_name: str = "nmap-container",
        use_docker: bool = True,
    ):
        self.exec_llm = exec_llm
        self.container_name = container_name
        self.use_docker = use_docker
        self.parser = LLMtoCommand()
        self.error_log = []

        self.nmap_prompt = PromptTemplate(
            input_variables=["description", "target"],
            template=nmap_executer_template,
        )
 
        self.nmap_chain = self.nmap_prompt | self.exec_llm
        self.msf_prompt = PromptTemplate(
            input_variables=["description", "target", "error"],
            template=metasploit_executer_template,
        )
        self.msf_chain = self.msf_prompt | self.exec_llm

    # def load_tasks(self) -> List[Dict]:
    #     try:
    #         with open(self.input_file, "r") as file:
    #             raw_tasks = json.load(file).get("tasks", [])
    #             return [parse_task(task) for task in raw_tasks]
    #     except (FileNotFoundError, json.JSONDecodeError, ValueError) as e:
    #         logging.error(f"Error loading tasks: {e}")
    #         return []

    def execute_command(
        self, task: Task
    ) -> Tuple[bool, Optional[str], Optional[str], Optional[str]]:
        """
        Executes a cybersecurity task (Nmap or Metasploit).
        Returns a tuple: (done, output, command, error)
        """
        try:
            if task.task_type == "nmap_scan":
                return self._execute_tool_task(
                    task,
                    generator=self.create_nmap_task,
                    parser=self.parser.parse_nmap,
                    executor=self.execute_nmap,
                    tool_name="Nmap",
                )

            elif task.task_type == "metasploit":
                return self._execute_tool_task(
                    task,
                    generator=self.create_msf_task,
                    parser=self.parser.parse_msf,
                    executor=self.execute_msf,
                    tool_name="Metasploit",
                )

            else:
                error = f"Unsupported task type: {task.task_type}"
                self.error_log.append(error)
                logger.error(error)
                return False, None, None, error

        except Exception as e:
            error = f"Unexpected error during task execution: {e}"
            self.error_log.append(error)
            logger.critical(error)
            return False, None, None, error

    def _execute_tool_task(
        self,
        task: Task,
        generator: Callable[[str, str, str], str],
        parser: Callable[[str], Tuple[Optional[str], Optional[str]]],
        executor: Callable[[str], Tuple[Optional[str], Optional[str]]],
        tool_name: str,
    ) -> Tuple[bool, Optional[str], Optional[str], Optional[str]]:
        """
        Executes a task for a specific tool (e.g., Nmap, Metasploit).
        """
        logger.info(f"Executing {tool_name} task: {task.description}")

        # Generate and parse command
        generated_command = generator(task.description, task.target, task.error)
        logger.debug(f"Generated command: {generated_command}")

        cmd, parse_error = parser(generated_command)

        if parse_error:
            self.error_log.append(parse_error)
            logger.error(f"{tool_name} parsing error: {parse_error}")
            return False, None, cmd, parse_error

        # Execute command
        output, exec_error = executor(cmd)

        if exec_error:
            self.error_log.append(exec_error)
            logger.error(f"{tool_name} execution error: {exec_error}")
            return False, output, cmd, exec_error

        logger.info(f"{tool_name} task completed successfully.")
        return True, output, cmd, None

    def create_nmap_task(self, description: str, target: str, error_text: str) -> str:
        try:
            logger.debug(
                f"Creating Nmap task for description: {description}, target: {target}, error_text: {error_text}"
            )
            result = self.nmap_chain.invoke(
                {
                    "description": description,
                    "target": target,
                    "error_text": error_text,
                }
            )
            logger.debug(f"Generated Nmap command: {result}")
            return result
        except Exception as e:
            error_msg = f"LLM command generation failed: {str(e)}"
            self.error_log.append(error_msg)
            logger.error(error_msg)
            return error_msg

    def execute_nmap(self, command: str) -> Tuple[Optional[str], Optional[str]]:
        if self.use_docker and self.container_name:
            command = f"docker exec {self.container_name} {command}"

        try:
            logger.debug(f"Executing command: {command}")
            result = subprocess.run(
                command, shell=True, capture_output=True, text=True, timeout=300
            )

            if result.returncode == 0:
                logger.info(f"Command executed successfully: {command}")
                return result.stdout, None
            else:
                error_msg = f"Command failed: {result.stdout} {result.stderr}"
                self.error_log.append(error_msg)
                logger.error(error_msg)
                return None, error_msg

        except subprocess.TimeoutExpired:
            error_msg = "Command timed out after 5 minutes"
            self.error_log.append(error_msg)
            logger.error(error_msg)
            return None, error_msg

        except Exception as e:
            error_msg = f"Execution error: {str(e)}"
            self.error_log.append(error_msg)
            logger.critical(error_msg)
            return None, error_msg

    def create_msf_task(self, description: str, target: str, error_text: str) -> str:
        try:
            logger.debug(
                f"Creating Metasploit task for description: {description}, target: {target}, error_text: {error_text}"
            )

            # Invoke the Metasploit command generation chain
            result = self.msf_chain.invoke(
                {"description": description, "target": target, "error_text": error_text}
            )

            logger.debug(f"Generated Metasploit command: {result}")
            return result
        except Exception as e:
            error_msg = f"LLM command generation failed: {str(e)}"
            self.error_log.append(error_msg)
            logger.error(error_msg)
            return error_msg

    def execute_msf(self, command: str) -> Tuple[Optional[str], Optional[str]]:
        if self.use_docker and self.container_name:
            command = f"docker exec {self.container_name} {command}"

        try:
            logger.debug(f"Executing Metasploit command: {command}")

            # Run the command in the shell
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300,  # 5-minute timeout
            )

            if self.exploit_is_correct(result.stdout):
                logger.info(f"Metasploit command executed successfully: {command}")
                return result.stdout, None
            else:
                error_msg = f"Metasploit command failed: {result.stdout}"
                self.error_log.append(error_msg)
                logger.error(error_msg)
                return None, result.stdout

        except subprocess.TimeoutExpired:
            error_msg = "Metasploit command timed out after 5 minutes"
            self.error_log.append(error_msg)
            logger.error(error_msg)
            return None, error_msg

        except Exception as e:
            error_msg = f"Metasploit execution error: {str(e)}"
            self.error_log.append(error_msg)
            logger.critical(error_msg)
            return None, error_msg

    def exploit_is_correct(self, msf_output: str) -> bool:
        """
        Parses Metasploit output and returns True if 'Exploit completed' is found,
        otherwise returns False. Includes exception handling.
        
        Args:
            msf_output (str): Full output from Metasploit module execution.

        Returns:
            bool: True if exploit was completed, False otherwise.
        """
        try:
            if "[*] Exploit completed" in msf_output:
                 return True
            elif "[*] Auxiliary module execution completed" in msf_output:
                return True
            else:
                return False
        except Exception as e:
            logger.error(f"[!] Error parsing output: {e}")
            return False