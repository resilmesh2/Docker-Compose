from langgraph.graph import StateGraph, END
from pentester.neo4j_connector import Neo4jConnector
from pentester.utils import PentestState,  Task
from pentester.executor import Executor
from pentester.memory_saver import MemoryAgent
from pentester.planner import Planner
from pentester.test_data import simpulate_completed_tasks, simulate_pending_tasks
from IPython.display import Image, display
from .config import ATTACKER_CONTAINER_NAME


class GraphBuilder:

    def __init__(self, memory_agent, executor, planner, network_graph_file, neo4j: Neo4jConnector, mode="scan"):
        # Create a memory agent
        self.memory_agent = memory_agent # MemoryAgent(mem_llm=mem_llm, network_graph_file=network_graph_file, neo4j=neo4j)
        self.executor = executor# Executor(exec_llm=exec_llm, container_name=ATTACKER_CONTAINER_NAME)
        self.planner = planner # Planner(planner_llm, neo4j, mode=mode)
        self.neo4j = neo4j
        
    ################# Workflow Graph ################
    # # State graph nodes
    # def plan_tasks(self, state: PentestState) -> PentestState:
    #     """Load initial tasks if none exist"""
    #     if not state["pending_tasks"]:
    #         return {"pending_tasks": self.executor.load_tasks()}
    #     print("plan tasks")
    #     return state

    def process_task(self, state: PentestState) -> PentestState:
        """Processes the next pending task and updates the state accordingly."""

        new_state = state.copy()
        new_state["current_phase"] = "execution"

        if not new_state["pending_tasks"]:
            return new_state  # No tasks to process

        pending_task = new_state["pending_tasks"][0]
        current_task = Task(**vars(pending_task))
        # need to give a task object to the function 
        execution_done, output, concrete_command, error = self.executor.execute_command(current_task)
        # Update task with execution results
        current_task.command = concrete_command
        current_task.command_output = output
        current_task.error = error
        current_task_id = current_task.task_id
        if error:
            new_state["errors"].append(error)
            if current_task.error_count > 4:
                new_state["failed_tasks"].append(current_task)
                # Remove failed task from pending
                new_state["pending_tasks"] = new_state["pending_tasks"][1:]
            else:
                current_task.error_count = current_task.error_count + 1
 

        elif execution_done:
            new_state["completed_tasks"].append(current_task)
            new_state["pending_tasks"] = new_state["pending_tasks"][1:]
            new_state["current_task"] = current_task

        # else:
        #     if current_task.error_count > 4:
        #         new_state["failed_tasks"].append(current_task)
        #         # Remove failed task from pending
        #         new_state["pending_tasks"] = new_state["pending_tasks"][1:]
        #     else:
        #         current_task.error_count = current_task.error_count + 1
        #     # Execution incomplete: update task in place
        #     new_state["pending_tasks"][0] = current_task
            

        print(f"EXECUTOR executed TASK {current_task_id}")
        return new_state


    def exec_to_save(self, state: PentestState) -> PentestState:
        new_state = state.copy()
        # Switch to "memory_saving" phase
        new_state["current_phase"] = "memory_saving"
        # Move completed tasks to pending
        new_state["pending_tasks"] = state["completed_tasks"].copy()
        #print("exec_to_save")
        return new_state


    def process_exec(self, state: PentestState) -> PentestState:
        """Process the first pending task with memory agent and update the state."""
        new_state = state.copy()

        if not new_state["pending_tasks"]:
            return new_state  # Nothing to process

        task = new_state["pending_tasks"][0]
        new_state["pending_tasks"] = new_state["pending_tasks"][1:]
        new_state["current_task"] = task
        task_id = task.task_id

        try:
            updated_task, success = self.memory_agent.extract_scan(task)
            if not success:
                print("updated task needed")
                updated_task = updated_task or {}

            # Replace matching task in completed_tasks, if any
            for i, t in enumerate(new_state["completed_tasks"]):
                if t.task_id == task_id and updated_task:
                    new_state["completed_tasks"][i] = updated_task
                    break

        except Exception as e:
            error_msg = str(e)
            # Optional: log or store error
            print(f"Error processing task {task_id}: {error_msg}")

        print(f"MEMORY AGENT saved INFO for TASK {task_id}")
        return new_state

    def retrive_network_info(self, state: PentestState) -> PentestState:
        """Retrieve network info, remove 'command_output' from completed tasks, and update the state's graph_data."""
        new_state = state.copy()
        # Update graph_data
        new_state["graph_data"] = self.memory_agent.get_network_info()
        #changes=str()
        # for task  in state['completed_tasks']:
        #     changes += task.task_summary
        # new_state["graph_data"]["changes"] = changes
        new_state['current_phase'] = "reporting"
        new_state["completed_tasks"] = []
        new_state["pending_tasks"] = []
        print("MEMORY AGENT retrived INFO")
        return new_state
    
    def plan_tasks(self, state: PentestState) -> PentestState:
        ## need to add a try eccept block
        new_state = state.copy()

        graph_data = new_state["graph_data"]
        new_tasks = self.planner.process_graph_data(graph_data)
        #self.planner.add_generated_to_tasks(new_tasks)
        new_state["pending_tasks"] = new_tasks
        new_state["current_phase"] = "execution"
        new_iteration = state["iteration"] + 1
        new_state["iteration"] = new_iteration
        print(f"PLANNER assigned TASKS, iteration: {new_iteration}")
        return new_state
    
    def display_state(self, state: PentestState) -> PentestState:
        self.memory_agent.save_network_graph(state['graph_data'])
        """Display formatted state information"""
        print(50*"-")
        print(f"network information: {state['graph_data']}")
        print(50*"-")
        print(50*"*")
        print("\n=== CURRENT STATE ===")
        print(f"Pending Tasks: {len(state['pending_tasks'])}")
        print(f"Errors: {len(state['errors'])}")
        print(50*"-")
        print(f"Completed EXEC & SAVE: {state['completed_tasks']}")
        print(50*"*")
        
        return state
    

    def build_scan_graph(self):

        builder = StateGraph(PentestState)

        builder.add_node("plan_tasks", self.plan_tasks)
        builder.add_node("process_task", self.process_task)
        builder.add_node("exec_to_save", self.exec_to_save)
        builder.add_node("process_exec", self.process_exec)
        builder.add_node("retrive_network_info", self.retrive_network_info)
        #builder.add_node("save_to_plan", self.save_to_plan)
        builder.add_node("display_state", self.display_state)

        # Step 1: plan_tasks → process_task
        builder.add_edge("plan_tasks", "process_task")

        # Entry point
        builder.set_entry_point("process_task")

        # Step 2: process_task loops or moves to exec_to_save
        builder.add_conditional_edges(
            "process_task",
            lambda s: "loop" if len(s["pending_tasks"]) > 0 and s["current_phase"] == "execution" else "next",
            {
                "loop": "process_task",
                "next": "exec_to_save"
            }
        )

        # Step 3: exec_to_save → process_exec
        builder.add_edge("exec_to_save", "process_exec")

        # Step 4: process_exec loops or moves to retrive_network_info
        builder.add_conditional_edges(
            "process_exec",
            lambda s: "loop" if s["pending_tasks"] and s["current_phase"] == "memory_saving" else "next",
            {
                "loop": "process_exec",
                "next": "retrive_network_info"
            }
        )

        builder.add_edge("exec_to_save", "process_exec")
       
       
        # Step 4: process_exec loops or moves to retrive_network_info
        builder.add_conditional_edges(
            "retrive_network_info",
            lambda s: "exit" if s["iteration"] > 2 else "loop",
            {
                "loop": "plan_tasks",
                "exit": "display_state"
            }
        )

        builder.add_edge("display_state", END)

        # # Step 5: retrive_network_info → display_state → END
        # builder.add_edge("retrive_network_info", "display_state")
        # builder.add_edge("display_state", END)

        graph = builder.compile()

        #image_bytes = graph.get_graph().draw_png()

        # # Display in notebook
        # display(Image(image_bytes))

        # with open("logs/graph_output.png", "wb") as f:
        #     f.write(image_bytes)

        return graph
 
    def build_xp_graph(self):

        builder = StateGraph(PentestState)

        builder.add_node("plan_tasks", self.plan_tasks)
        builder.add_node("process_task", self.process_task)
        builder.add_node("exec_to_save", self.exec_to_save)
        builder.add_node("process_exec", self.process_exec)
        builder.add_node("retrive_network_info", self.retrive_network_info)
        #builder.add_node("save_to_plan", self.save_to_plan)
        builder.add_node("display_state", self.display_state)

        # Step 1: plan_tasks → process_task
        builder.add_edge("plan_tasks", "process_task")

        # Entry point
        builder.set_entry_point("retrive_network_info")

        # Step 2: process_task loops or moves to exec_to_save
        builder.add_conditional_edges(
            "process_task",
            lambda s: "loop" if len(s["pending_tasks"]) > 0 and s["current_phase"] == "execution" else "next",
            {
                "loop": "process_task",
                "next": "exec_to_save"
            }
        )

        # Step 3: exec_to_save → process_exec
        builder.add_edge("exec_to_save", "process_exec")

        # Step 4: process_exec loops or moves to retrive_network_info
        builder.add_conditional_edges(
            "process_exec",
            lambda s: "loop" if s["pending_tasks"] and s["current_phase"] == "memory_saving" else "next",
            {
                "loop": "process_exec",
                "next": "retrive_network_info"
            }
        )

        builder.add_edge("exec_to_save", "process_exec")
       
       
        # Step 4: process_exec loops or moves to retrive_network_info
        builder.add_conditional_edges(
            "retrive_network_info",
            lambda s: "exit" if s["iteration"] > 1 else "loop",
            {
                "loop": "plan_tasks",
                "exit": "display_state"
            }
        )

        builder.add_edge("display_state", END)

        # # Step 5: retrive_network_info → display_state → END
        # builder.add_edge("retrive_network_info", "display_state")
        # builder.add_edge("display_state", END)

        graph = builder.compile()

        #image_bytes = graph.get_graph().draw_png()

        # # Display in notebook
        # display(Image(image_bytes))

        # with open("logs/graph_output.png", "wb") as f:
        #     f.write(image_bytes)

        return graph
 