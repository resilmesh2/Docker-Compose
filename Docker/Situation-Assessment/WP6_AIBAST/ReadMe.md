## üó∫Ô∏è Architecture

### High-level overview
This project is a **LangGraph multi-agent workflow** with three agents that run in a closed loop:

- **Planner** ‚Äî decomposes the goal into concrete tasks.  
- **Executor** ‚Äî runs tasks using tools (**Nmap** / **Metasploit**) depending on the active mode.  
- **Memory Saver** ‚Äî captures console output and artifacts, stores summaries & retrieval keys, and surfaces the most relevant context back to the Planner.  

The loop continues until the plan is complete or guardrails stop execution.

---

### Operational modes
- **Scanning mode**: enumerate hosts/services with **Nmap**; record findings (open ports, versions, banners, OS guesses).  
- **Exploitation mode**: attempt exploitation with **Metasploit** based on confirmed/prioritized findings; record outcomes and artifacts (sessions, shells, proof files).  
- **Ros Exploitaiton mode**: based on porti indication (11311) it tries to find topic in ROS1 ROS2 and record  data from the communticion in the topics.

The **USER** initilzies the pentest with e.g. a nmpa scan of a IP range and switches the mode eventually

---

### Agents & models

| Agent        | Role                               | Model (exact name)                                        |
|--------------|------------------------------------|-----------------------------------------------------------|
| **Planner**      | Task decomposition & next-step selection | `meta-llama/llama-3.3-70b-instruct`                       |
| **Executor**     | Tool-calling & procedure execution      | `meta-llama/llama-4-maverick-17b-128e-instruct-fp8`       |
| **Memory Saver** | Summarize, persist, and retrieve        | `meta-llama/llama-4-scout-17b-16e-instruct`               |

---

### Tools used by the Executor
- **nmap** (CLI) for discovery & service enumeration  
- **metasploit** (RPC/CLI) for exploitation workflows  

## üóÑÔ∏è State & Task

The workflow is built around two units: the **State** and the **Task**.

---

### State (LangGraph)

The **State** (`PentestState`) is the shared memory passed between agents. It tracks:

- `iteration` ‚Üí current loop count  
- `pending_tasks` ‚Üí tasks awaiting execution  
- `completed_tasks` ‚Üí executed tasks pending memory processing  
- `current_phase` ‚Üí `"execution"`, `"memory_saving"`, or `"reporting"`  
- `errors` ‚Üí collected errors  
- `graph_data` ‚Üí data for reporting/visualization  

---

### Task

A **Task** is the atomic unit of work:

- **task_id** ‚Üí unique identifier  
- **description** ‚Üí generated by the Planner  
- **command** ‚Üí created by the Executor  
- **command_output** ‚Üí raw tool output  
- **task_summary** ‚Üí concise result from the Memory Saver  

**Lifecycle:** Planner defines ‚Üí Executor runs ‚Üí Memory Saver summarizes.


## üß† Memory

In addition to the dynamic **State**, the system maintains a persistent **Memory** that is independent of agent state and reflects the **network topology** being tested.

- Each **network node** (e.g. `192.168.0.1`) is a key in a JSON structure.  
- Under each node we store a reduced **task history** with:
  - `id` ‚Üí task identifier  
  - `task_type` ‚Üí action type (e.g. `nmap_scan`, `metasploit`)  
  - `instruction` ‚Üí the executed step  
  - `memory` ‚Üí concise summary of results and changes  

This design allows the system to:
- Retrieve host findings at any time  
- Accumulate knowledge incrementally (scans ‚Üí exploits)  
- Provide the Planner with historical context  

The memory is persisted in **JSON format** at the path defined in `.config` (`NETWORK_GRAPH`), forming a continuously updated **knowledge graph** of the target network.


---

### Example entry

```json
{
  "192.168.0.1": [
    {
      "id": 1,
      "task_type": "nmap_scan",
      "instruction": "Perform a basic network discovery scan.",
      "memory": "Node discovered via Nmap range scan."
    },
    {
      "id": 2,
      "task_type": "nmap_scan",
      "instruction": "Intensive scan to identify open ports and services.",
      "memory": "Found Linux OS (4.15-5.19), OpenWrt 21.02, MikroTik RouterOS 7.2-7.5. Open ports: 111/tcp, 8080/tcp. Hop count: 1."
    },
    {
      "id": 4,
      "task_type": "metasploit",
      "instruction": "Exploit OpenWrt and MikroTik RouterOS to gain RCE.",
      "memory": "Exploit unsuccessful; no sessions or credentials obtained."
    }
  ]
}
```

## üõ†Ô∏è Main Script & Components

### Main Script
The entrypoint orchestrates the entire workflow:
- Manages the event loop (`Planner ‚Üí Executor ‚Üí Memory Saver ‚Üí Planner`)  
- Creates and injects agents as modular classes  
- Handles configuration and logging

### Logging
- All runtime logs are written to the `logs/` folder.  
- Each run of the workflow appends to a shared log file (`pentest.log` by default, see `.config`).  
- Logs include timestamps, levels, module names, and messages, making it easy to trace workflow progress.

---

### LLM Integration
Agents are designed to be **LLM-agnostic**. You can inject any LLM client that is compatible with the **LangChain API**:
- ‚úÖ **OpenAI API** (e.g. GPT-4, GPT-4o-mini)  
- ‚úÖ **HuggingFace Hub** (transformers and hosted models)  
- ‚úÖ **Novita**  
- ‚ûï Any other LangChain-supported LLM

This separation means you can swap providers easily (cloud-hosted or on-premise).

---

### Prompt Templates
Prompt templates are stored under `.prompt_templates/` and used by LangChain chains for each agent:

- **Planner**: templates for generating Nmap and Metasploit tasks  
- **Executor**: templates for turning Planner instructions into concrete shell commands  
- **Memory Saver**: 
  - templates for summarizing Nmap and Metasploit outputs  
  - templates for merging new discoveries into the existing **graph memory**

This structure makes it easy to adapt or extend the workflow to new tools by simply adding prompt templates.

---